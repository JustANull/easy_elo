extern crate chrono;
extern crate crossbeam;
extern crate ease;
extern crate getopts;

use getopts::Options;
use std::env;
use std::path::Path;

mod types {
    use chrono::DateTime;
    use chrono::FixedOffset;
    use serde;
    use serde_json;
    use std::collections::HashMap;
    use std::fs::File;
    use std::io::Error as IoError;
    use std::path::Path;

    // All of a tournament's matches, as received from the Challonge API
    // Only correctly parses completed tournaments
    pub type TournamentChallonge = Vec<TournamentMatchChallongeWrapper>;
    // A tournament match, as received from the Challonge API
    // Only correctly parses completed matches
    #[derive(Debug, Deserialize)]
    pub struct TournamentMatchChallonge {
        attachment_count: Option<i64>, // type unsure
        created_at: DateTimeWrapper,
        group_id: Option<i64>, // type unsure
        has_attachment: bool,
        id: i64, // the exact, unique match id
        identifier: String, // what the match is called "e.g. the winner of match A plays in match B"
        location: Option<String>, // type unsure
        loser_id: i64,
        optional: bool, // should always be "false" afaik
        player1_id: i64,
        player1_is_prereq_match_loser: bool,
        player1_prereq_match_id: Option<i64>,
        player1_votes: Option<i64>, // type unsure, almost definitely wrong
        player2_id: i64,
        player2_is_prereq_match_loser: bool,
        player2_prereq_match_id: Option<i64>,
        player2_votes: Option<i64>, // type unsure, almost definitely wrong
        round: i64,
        scheduled_time: Option<DateTimeWrapper>,
        started_at: DateTimeWrapper,
        state: String, // should always be "complete"
        tournament_id: i64,
        underway_at: Option<DateTimeWrapper>,
        updated_at: DateTimeWrapper,
        winner_id: i64,
        prerequisite_match_ids_csv: String, // you must be joking
        scores_csv: String // see the above ^
    }
    // Challonge API fixup
    #[derive(Debug, Deserialize)]
    struct TournamentMatchChallongeWrapper {
        #[serde(rename="match")]
        match_obj: TournamentMatchChallonge
    }

    // A map from a tournament id "e.g. tloc-mnm32" to a vector of match results.
    pub type TournamentCache = HashMap<String, Vec<MatchResult>>;
    // ditto. contains wrapped date times to move items through chrono
    type TournamentCacheWrapped = HashMap<String, Vec<MatchResultWrapped>>;
    // The time of a match and the winner and loser
    pub type MatchResult = (DateTime<FixedOffset>, String, String);
    // ditto. contains wrapped date time to move the item through chrono
    type MatchResultWrapped = (DateTimeWrapper, String, String);

    #[derive(Debug)]
    pub enum CacheWriteError {
        IoError(IoError),
        JsonError(serde_json::Error)
    }

    pub fn cache_read(cache_path: &Path) -> Result<TournamentCache, serde_json::Error> {
        Ok(unwrap(try!(parse(cache_path))))
    }
    pub fn cache_write(cache_path: &Path, cache: TournamentCache) -> Result<(), CacheWriteError> {
        serde_json::to_writer(&mut try!(File::create(cache_path)
                                        .map_err(CacheWriteError::IoError)),
                              &wrap(cache)).map_err(CacheWriteError::JsonError)
    }

    fn parse(cache_path: &Path) -> Result<TournamentCacheWrapped, serde_json::Error> {
        File::open(cache_path)
            .map(|f| serde_json::from_reader(f))
            .unwrap_or_else(|_| Ok(HashMap::new()))
    }
    fn wrap(unwrapped_cache: TournamentCache) -> TournamentCacheWrapped {
        unwrapped_cache.into_iter().map(|(k, v)| {
            (k, v.into_iter().map(|(dt, winner, loser)| {
                (DateTimeWrapper(dt), winner, loser)
            }).collect())
        }).collect()
    }
    fn unwrap(wrapped_cache: TournamentCacheWrapped) -> TournamentCache {
        wrapped_cache.into_iter().map(|(k, v)| {
            (k, v.into_iter().map(|(dt, winner, loser)| {
                let DateTimeWrapper(dt) = dt;
                (dt, winner, loser)
            }).collect())
        }).collect()
    }

    // Here be dragons. The wrappers to move DateTime items through serde
    #[derive(Debug)]
    struct DateTimeWrapper(DateTime<FixedOffset>);
    impl serde::ser::Serialize for DateTimeWrapper {
        fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error> where S: serde::Serializer {
            serializer.visit_str(&self.0.to_rfc3339())
        }
    }
    impl serde::de::Deserialize for DateTimeWrapper {
        fn deserialize<D>(deserializer: &mut D) -> Result<DateTimeWrapper, D::Error> where D: serde::Deserializer {
            deserializer.visit(DateTimeVisitor)
        }
    }
    struct DateTimeVisitor;
    impl serde::de::Visitor for DateTimeVisitor {
        type Value = DateTimeWrapper;

        fn visit_str<E>(&mut self, s: &str) -> Result<Self::Value, E> where E: serde::de::Error {
            match DateTime::parse_from_rfc3339(s) {
                Ok(dt) => Ok(DateTimeWrapper(dt)),
                Err(_) => Err(serde::de::Error::syntax("expect an ISO 8601 datetime"))
            }
        }
    }
}

fn usage(prog: &str, opts: Options) {
    let brief = format!("Usage: {} [options]", prog);
    print!("{}", opts.usage(&brief));
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    opts.optflag("h", "help", "Print this message")
        .optopt("i", "input", "The file to input tournament IDs from (default input.txt)", "INPUT_FILE")
        .reqopt("k", "api-key", "The Challonge API key (required)", "API_KEY")
        .optopt("c", "cache-file", "The file to store the tournament cache inside (default cache.json)", "CACHE_FILE")
        .optopt("o", "output", "The file to output rankings to (default output.json)", "OUTPUT_FILE");
    let matches = match opts.parse(&args[1..]) {
        Ok(m) => m,
        Err(f) => {
            println!("Error: {}", f.to_string());
            usage(&program, opts);
            return;
        }
    };

    if matches.opt_present("h") {
        usage(&program, opts);
        return;
    }

    let api_key = matches.opt_str("k").unwrap();

    let input_pathname = matches.opt_str("i").unwrap_or("input.txt".to_owned());
    let cache_pathname = matches.opt_str("c").unwrap_or("cache.json".to_owned());
    let output_pathname = matches.opt_str("o").unwrap_or("output.json".to_owned());

    let input_path = Path::new(&input_pathname);
    let cache_path = Path::new(&cache_pathname);
    let output_path = Path::new(&output_pathname);

    let mut cache = types::cache_read(&cache_path).expect("The cache should read successfully");

    let matches_url = ease::Url::parse("https://api.challonge.com/v1/tournaments/tloc-mnm50/matches.json").unwrap();
    let matches: types::TournamentChallonge = serde_json::from_str(&ease::Request::new(matches_url).param("api_key", &api_key).get().unwrap().body).expect("This should work");
    println!("{:?}", matches);

    types::cache_write(&cache_path, cache).expect("The cache should write successfully");
}
