extern crate chrono;
extern crate ease;
extern crate getopts;

mod interop {
    use chrono::DateTime;
    use chrono::FixedOffset;
    use serde::{Deserializer, Serializer};
    use serde::de::{Deserialize, Error, Visitor};
    use serde::ser::Serialize;
    use std::ops::{Deref, DerefMut};

    #[derive(Debug)]
    pub struct SerializableDateTime(DateTime<FixedOffset>);
    impl Serialize for SerializableDateTime {
        fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error> where S: Serializer {
            serializer.visit_str(&self.0.to_rfc3339())
        }
    }
    impl Deserialize for SerializableDateTime {
        fn deserialize<D>(deserializer: &mut D) -> Result<SerializableDateTime, D::Error> where D: Deserializer {
            deserializer.visit(DateTimeVisitor)
        }
    }
    struct DateTimeVisitor;
    impl Visitor for DateTimeVisitor {
        type Value = SerializableDateTime;

        fn visit_str<E>(&mut self, s: &str) -> Result<Self::Value, E> where E: Error {
            match DateTime::parse_from_rfc3339(s) {
                Ok(dt) => Ok(SerializableDateTime(dt)),
                Err(_) => Err(Error::syntax("expect an ISO 8601 datetime"))
            }
        }
    }

    impl Deref for SerializableDateTime {
        type Target = DateTime<FixedOffset>;

        fn deref<'a>(&'a self) -> &'a DateTime<FixedOffset> {
            &self.0
        }
    }
    impl DerefMut for SerializableDateTime {
        fn deref_mut<'a>(&'a mut self) -> &'a mut DateTime<FixedOffset> {
            &mut self.0
        }
    }
}
mod types {
    use interop::SerializableDateTime;
    use serde_json;
    use std::collections::HashMap;
    use std::fs::File;
    use std::io::Error as IoError;
    use std::path::Path;

    // All of a tournament's matches, as received from the Challonge API
    // Only correctly parses completed tournaments
    pub type TournamentChallonge = Vec<TournamentMatchChallonge>;
    // A tournament match, as received from the Challonge API
    // Only correctly parses completed matches
    #[derive(Debug, Deserialize)]
    pub struct TournamentMatchChallongeInterior {
        attachment_count: Option<i64>, // type unsure
        created_at: SerializableDateTime,
        group_id: Option<i64>, // type unsure
        has_attachment: bool,
        id: i64, // the exact, unique match id
        identifier: String, // what the match is called "e.g. the winner of match A plays in match B"
        location: Option<String>, // type unsure
        loser_id: i64,
        optional: bool, // should always be "false" afaik
        player1_id: i64,
        player1_is_prereq_match_loser: bool,
        player1_prereq_match_id: Option<i64>,
        player1_votes: Option<i64>, // type unsure, almost definitely wrong
        player2_id: i64,
        player2_is_prereq_match_loser: bool,
        player2_prereq_match_id: Option<i64>,
        player2_votes: Option<i64>, // type unsure, almost definitely wrong
        round: i64,
        scheduled_time: Option<SerializableDateTime>,
        started_at: SerializableDateTime,
        state: String, // should always be "complete"
        tournament_id: i64,
        underway_at: Option<SerializableDateTime>,
        updated_at: SerializableDateTime,
        winner_id: i64,
        prerequisite_match_ids_csv: String, // you must be joking
        scores_csv: String // see the above ^
    }
    // Challonge API fixup
    #[derive(Debug, Deserialize)]
    struct TournamentMatchChallonge {
        #[serde(rename="match")]
        match_obj: TournamentMatchChallongeInterior
    }

    // A map from a tournament id "e.g. tloc-mnm32" to a vector of match results.
    pub type TournamentCache = HashMap<String, Vec<MatchResult>>;
    // The time of a match and the winner and loser
    pub type MatchResult = (SerializableDateTime, String, String);

    #[derive(Debug)]
    pub enum CacheWriteError {
        IoError(IoError),
        JsonError(serde_json::Error)
    }

    pub fn cache_read(cache_path: &Path) -> Result<TournamentCache, serde_json::Error> {
        Ok(try!(parse(cache_path)))
    }
    pub fn cache_write(cache_path: &Path, cache: TournamentCache) -> Result<(), CacheWriteError> {
        serde_json::to_writer(&mut try!(File::create(cache_path)
                                        .map_err(CacheWriteError::IoError)),
                              &cache).map_err(CacheWriteError::JsonError)
    }

    fn parse(cache_path: &Path) -> Result<TournamentCache, serde_json::Error> {
        File::open(cache_path)
            .map(|f| serde_json::from_reader(f))
            .unwrap_or_else(|_| Ok(HashMap::new()))
    }
}

use getopts::Options;
use std::env;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::Path;

fn usage(prog: &str, opts: Options) {
    let brief = format!("Usage: {} [options]", prog);
    print!("{}", opts.usage(&brief));
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    opts.optflag("h", "help", "Print this message")
        .optopt("i", "input", "The file to input tournament IDs from (default input.txt)", "INPUT_FILE")
        .reqopt("k", "api-key", "The Challonge API key (required)", "API_KEY")
        .optopt("c", "cache-file", "The file to store the tournament cache inside (default cache.json)", "CACHE_FILE")
        .optopt("o", "output", "The file to output rankings to (default output.json)", "OUTPUT_FILE");
    let matches = match opts.parse(&args[1..]) {
        Ok(m) => m,
        Err(f) => {
            println!("Error: {}", f.to_string());
            usage(&program, opts);
            return;
        }
    };

    if matches.opt_present("h") {
        usage(&program, opts);
        return;
    }

    let api_key = matches.opt_str("k").unwrap();

    let input_pathname = matches.opt_str("i").unwrap_or("input.txt".to_owned());
    let cache_pathname = matches.opt_str("c").unwrap_or("cache.json".to_owned());
    let output_pathname = matches.opt_str("o").unwrap_or("output.json".to_owned());

    let input_path = Path::new(&input_pathname);
    let cache_path = Path::new(&cache_pathname);
    let output_path = Path::new(&output_pathname);

    let mut cache = types::cache_read(&cache_path).expect("The cache should read successfully");

    let input_file = BufReader::new(File::open(input_path)
                                    .expect("The input file should read successfully"));
    let input_lines = input_file.lines().map(|l| l.expect("The lines should be properly formatted"));
    let input_needed = input_lines.filter(|l| !cache.contains_key(l)).collect::<Vec<String>>();

    for line in input_needed {
        println!("{}", line);
    }

    let matches_url = ease::Url::parse("https://api.challonge.com/v1/tournaments/tloc-mnm50/matches.json").unwrap();
    let matches: types::TournamentChallonge = serde_json::from_str(&ease::Request::new(matches_url).param("api_key", &api_key).get().unwrap().body).expect("This should work");

    types::cache_write(&cache_path, cache).expect("The cache should write successfully");
}
